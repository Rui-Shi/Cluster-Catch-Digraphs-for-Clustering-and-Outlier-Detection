#####
## synthetic datasets that contain 6% outliers(3 outliers out of 50)
# n: number of points in each data set.
# n0: number of outliers (the last 6 objects are outliers)
# d: dimensionality
# min and max: ranges in each dimension (normal data)
# data.otl: data set that contains outliers
# len: number of data set
# sft: the distance to shift (5,10,15,20)
#####
##shift by 10
set.seed(123)
len = 100
n = 45
n0 = 5
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.10 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 5
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.10 = c(data.otl.list.10,list(data.otl))
}
ksccd.connected(data.otl.list.10[[1]],m = 1.35, sequential=FALSE,alpha=0.05)
plot(data.otl.list.10[[1]])
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(20)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.10, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.10[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
data.Ex = cbind(data.otl.list.10[[1]],result.Ex$R)
plot(data.otl.list.10[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,30))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
result.Ex$member
data.Ex
#####
##shift by 15
set.seed(321)
len = 100
n = 45
n0 = 5
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.15 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[2]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.15 = c(data.otl.list.15,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.15, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.15[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.15[[1]],result.Ex$R)
plot(data.otl.list.15[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,35))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
data.Ex
#####
##shift by 20
set.seed(321)
len = 100
n = 45
n0 = 5
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.20 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[3]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.20 = c(data.otl.list.20,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.20, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.20[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.20[[1]],result.Ex$R)
plot(data.otl.list.20[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,40))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
#####
##shift by 25
set.seed(321)
len = 100
n = 45
n0 = 5
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.25 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[4]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.25 = c(data.otl.list.25,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.25, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.25[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.25[[1]],result.Ex$R)
plot(data.otl.list.25[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,45))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
5%
######################### datasets with outliers ###############################
#####
## synthetic datasets that contain 6% outliers(3 outliers out of 50)
# n: number of points in each data set.
# n0: number of outliers (the last 6 objects are outliers)
# d: dimensionality
# min and max: ranges in each dimension (normal data)
# data.otl: data set that contains outliers
# len: number of data set
# sft: the distance to shift (5,10,15,20)
cont.level = 0.05 #contaminate levels
#####
##shift by 10
set.seed(123)
len = 100
n1 = n*(1-cont.level)
n0 = n-n1
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.10 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 5
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.10 = c(data.otl.list.10,list(data.otl))
}
ksccd.connected(data.otl.list.10[[1]],m = 1.35, sequential=FALSE,alpha=0.05)
plot(data.otl.list.10[[1]])
data.otl.list.10[[1]]
n1
cont.level = 0.1 #contaminate levels
#####
##shift by 10
set.seed(123)
len = 100
n1 = n*(1-cont.level)
n0 = n-n1
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.10 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 5
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.10 = c(data.otl.list.10,list(data.otl))
}
ksccd.connected(data.otl.list.10[[1]],m = 1.35, sequential=FALSE,alpha=0.05)
plot(data.otl.list.10[[1]])
n1
n
n = 50
n1 = n*(1-cont.level)
cont.level = 0.1 #contaminate levels
#####
##shift by 10
set.seed(123)
len = 100
n1 = n*(1-cont.level)
n0 = n-n1
d = 2
sft = c(10,15,20,25)
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.otl.list.10 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 5
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.10 = c(data.otl.list.10,list(data.otl))
}
ksccd.connected(data.otl.list.10[[1]],m = 1.35, sequential=FALSE,alpha=0.05)
plot(data.otl.list.10[[1]])
n1
data.otl.list.10[[1]]
library(parallel)
library(plotrix)
library(dplyr)
library(MASS)
source("C:/Users/shiru/OneDrive/桌面/code/ccds/ccd_ks_NEW.R")
source("C:/Users/shiru/OneDrive/桌面/code/ccds/functions.R")
set.seed(123)
###code for KS-CCDs###
#source("G:/OneDrive - Auburn University/Research Outliers Detection/code/ccds/ccd_ks_NEW.R")
#source("G:/OneDrive - Auburn University/Research Outliers Detection/code/ccds/functions.R")
######################### Normal datasets ###############################
#####
## simulate n=50 uniform data within [0,10]x[0,10]
# n: number of points in each data set.
# d: dimensionality
# min and max: ranges in each dimension
# len: number of dataset simulated
len = 1000
n = 50
d = 2
range1 = c(min=0,max=10)
range2 = c(min=0,max=10)
range = rbind(range1,range2)
data.list = NULL
for(i in 1:len){
data = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
colnames(data) = c(1:d)
data.list = c(data.list,list(data))
}
source("C:/Users/shiru/OneDrive/桌面/code/KS-CCDs & mKNN/functions/mKNN_CCD_functions.R")
#####
#parallel computation
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.seq = parLapply(cl, data.list, connected.ksccd.m)
stopCluster(cl)
m.max.seq = unlist(m.max.seq)
t2 = Sys.time()
t2-t1
m.max.0.05 = quantile(m.max.seq,0.05) # the 5% quantile of the 1000 generated m ##
print(m.max.0.05)
mean(m.max.seq)
den = density(m.max.seq)
plot(den,main="the empirical distribution of m (d=2, n=50, uniform)")
######################### datasets with outliers ###############################
#####
## synthetic datasets that contain 6% outliers(3 outliers out of 50)
# n: number of points in each data set.
# n0: number of outliers (the last 6 objects are outliers)
# d: dimensionality
# min and max: ranges in each dimension (normal data)
# data.otl: data set that contains outliers
# len: number of data set
# sft: the distance to shift (5,10,15,20)
cont.level = 0.1 #contaminate levels
#####
##shift by 10
set.seed(123)
len = 100
n1 = n*(1-cont.level)
n0 = n-n1
d = 2
sft = c(10,15,20,25)
data.otl.list.10 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 5
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.10 = c(data.otl.list.10,list(data.otl))
}
ksccd.connected(data.otl.list.10[[1]],m = 1.35, sequential=FALSE,alpha=0.05)
plot(data.otl.list.10[[1]])
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(20)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.10, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.10[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.10[[1]],result.Ex$R)
plot(data.otl.list.10[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,30))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
#####
##shift by 15
set.seed(321)
data.otl.list.15 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[2]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.15 = c(data.otl.list.15,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.15, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.15[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.15[[1]],result.Ex$R)
plot(data.otl.list.15[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,35))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
#####
##shift by 20
set.seed(321)
data.otl.list.20 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[3]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.20 = c(data.otl.list.20,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.20, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.20[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.20[[1]],result.Ex$R)
plot(data.otl.list.20[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,40))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
#####
##shift by 25
set.seed(321)
data.otl.list.25 = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[4]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 10
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.otl.list.25 = c(data.otl.list.25,list(data.otl))
}
#parallel computation to find the m for the data set that contains outliers
cores = detectCores()
cl = makeCluster(cores)
t1 = Sys.time()
m.max.otl.seq = parLapply(cl, data.otl.list.25, connected.ksccd.m)
stopCluster(cl)
m.max.otl.seq = unlist(m.max.otl.seq)
t2 = Sys.time()
t2-t1
print(m.max.otl.seq)
length(which(m.max.otl.seq<m.max.0.05))/len # the percentage of the data.otl where mutiple components (outliers or clusters) could be detected.
## plot one of the result
result.Ex = ksccd.connected(data.otl.list.25[[1]],m.max.0.05,sequential=FALSE, alpha=0.05)
result.Ex$member
data.Ex = cbind(data.otl.list.25[[1]],result.Ex$R)
plot(data.otl.list.25[[1]],xlab = "X", ylab = "Y",pch=20,ylim=c(-20,20),xlim=c(-10,45))
for(i in 1:length(data.Ex[,1])){
draw.circle(data.Ex[i,1],data.Ex[i,2],data.Ex[i,3],nv=1000,lwd=0.01)
}
