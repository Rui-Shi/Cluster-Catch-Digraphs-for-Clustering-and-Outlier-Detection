library(parallel)
library(plotrix)
library(dplyr)
library(MASS)
library(doParallel)
t1 = Sys.time()
set.seed(1)
len = 1000
n = 50
d = 2
cont = 0.05 #contaminate levels
i = 1
range = NULL
while(i <= d){
range.temp = c(min=0,max=1)
range = rbind(range,range.temp)
i = i + 1
}
rownames(range) = c(1:d)
set.seed(2)
len = 100
n1 = round(n*(1-cont))
n0 = n-n1
sft = c(2,3,4)
data.list = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[1]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 2
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.list = c(data.list,list(data.otl))
}
library(e1071)
library(quadprog)
library(nloptr)
objfun = function(x, data){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 3 # penality parameter
data = data.list[[3]][1:48,]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 500000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,50)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 3 # penality parameter
data = data.list[[3]][1:48,]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 500000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
result
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 3 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
result
#####
##shift by 25
set.seed(4)
data.list = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + sft[3]
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 25
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.list = c(data.list,list(data.otl))
}
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 3 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
set.seed(4)
data.list = NULL
for(i in 1:len){
normal = apply(range,1,function(t){
return(runif(n1,t[1],t[2]))
})
range.outlier = range
range.outlier[1,] = range.outlier[1,] + 20
outlier = apply(range.outlier,1,function(t){
return(runif(n0,t[1],t[2]))   # mean shift by 25
})
data.otl = rbind(normal,outlier)
colnames(data.otl) = c(1:d)
#plot(data.otl)
data.list = c(data.list,list(data.otl))
}
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 3 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 0.1 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(1,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 0.1 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(C,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
result
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(L)
}
C = 1 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-5 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-5,
"maxeval"= 1000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(C,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
M = matrix(c(1,2,3,4),byrow=T)
M%*%t(M)
M = matrix(c(1,2,3,4),byrow=T,nrow=2)
M%*%t(M)
diag(M)
c(1,2)*diag(M)
c(1,2,3)*diag(M)
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 1 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-4 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-4,
"maxeval"= 20000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(C,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
data
objfun = function(x){ # objective function L
data_alpha = diag(x)%*%data
L = sum(x*diag(data%*%t(data))) - sum(data_alpha%*%t(data_alpha))
return(-L)
}
C = 0.1 # penality parameter
data = data.list[[6]]
n = dim(data)[1] # length of the data set
library(nloptr)
# Define the constraint function
confun <- function(x) {
return(sum(x)-1)
}
# Set the optimization options
local_opts <- list( "algorithm" = "NLOPT_GN_ISRES", "xtol_rel" = 1.0e-4 )
opts <- list( "algorithm"= "NLOPT_GN_ISRES",
"xtol_rel"= 1.0e-4,
"maxeval"= 20000000,
"local_opts" = local_opts,
"print_level" = 0 )
# Run the optimization
result <- nloptr(x0 = c(rep(C,n)),
eval_f = objfun,
lb = rep(0,n),
ub = rep(C,n),
eval_g_eq = confun,
opts = opts,
)
result$solution
sum(result$solution)
colSums(result$solution*data)
install.packages("reticulate")
py_run_string("import numpy as np")
library(reticulate)
py_run_string("import numpy as np")
library(reticulate)
py_run_string("import numpy as np")
py_run_string("my_python_array = np.array([2,4,6,8])")
py_run_string("for item in my_python_array: print(item)"
)
s = py_run_string("for item in my_python_array: print(item)")
s
print(s)
View(s)
View(s)
py$my_python_array
library(reticulate)
py_run_string("import numpy as np")
py_run_string("my_python_array = np.array([2,4,6,8])")
s = py_run_string("for item in my_python_array: print(item)")
py
library(reticulate)
py_run_string("import numpy as np")
py_run_string("my_python_array = np.array([2,4,6,8])")
py_run_string("for item in my_python_array: print(item)")
py
py$item
py$r
library(reticulate)
py_run_string()
py_run_string("import sys")
py_run_string("sys.path.append("..")")
library(reticulate)
py_run_string("import sys")
py_run_string("sys.path.append('..')")
py_run_string("import numpy as np")
py_run_string("from src.BaseSVDD import BaseSVDD")
library(reticulate)
py_run_string("import sys")
py_run_string("import os")
py_run_string("print(os. getcwd()")
library(reticulate)
py_run_string("import sys")
py_run_string("import os")
py_run_string("print(os. getcwd())")
library(reticulate)
py_run_string("import sys")
py_run_string("import os")
py_run_string("print(os.getcwd())")
library(reticulate)
py_run_string("import sys")
py_run_string("import os")
py_run_string("os.chdir('D:\code_working_folder\KS-MCGs\simulations\Uniform_MeanSlippage\SVDD-Python-master')")
py_run_string("import sys")
py_run_string("import os")
py_run_string("os.chdir('D:/code_working_folder/KS-MCGs/simulations/Uniform_MeanSlippage/SVDD-Python-master')")
py_run_string("import numpy as np")
py_run_string("from src.BaseSVDD import BaseSVDD")
py_run_string("import sys
import os")
py_run_string("import sys
import os")
