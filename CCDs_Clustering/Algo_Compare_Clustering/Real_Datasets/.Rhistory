# low.num is the lowest cardinality of a ball
# r.seq is the number of breaks in the Kest analysis of radii
# quantile to be used as the confidence interval max
# simul is the provided simulation for the problem, if null, compute
# scores: whether to calculate the outlyingness scores
ccd.Kest.edge.quantile <- function(dx, ddx, low.num, method="non-dynamic", r.seq, quan, simul=NULL, niter, scores=F){
n <- nrow(dx)
d <- ncol(dx)
R <- rep(0,n)
#rr <- seq(1/r.seq, 1, 1/r.seq)
# the new simulation function
if(!is.null(simul)){
Kest.slopes <- simul
} else if(method=="non-dynamic"){
Kest.slopes <- Kest.simpois.edge.quantile(n, d, r.seq, quan, niter)
} else {
Kest.slopes <- Kest.simpois.edge.quantile.dynamic(n, d, r.seq, quan, niter)
}
rr = Kest.slopes$r
if(!scores){
for(i in 1:n){
o.d <- order(ddx[i,]) # the distance vector if i_th object
for(j in low.num:n){
r <- ddx[i,o.d[j]]*rr
sc <- ddx[i,o.d[j]]
# if(sc==0) sc=1 # when two points overlap
Kest.obs <- Kest.f.edge(ddx[o.d[1:j],o.d[1:j]],r,sc,d)
# check the values, if rejected, set the R[i] as the radius
lo.hi <- Kest.slopes$quan[[as.character(quan)]][j,]
flag <- (Kest.obs > lo.hi)
if(any(flag)){
if(j==low.num) R[i] <- 0
else R[i] <- ddx[i,o.d[j-1]]
break
} else if(j==n){
R[i] <- 0
break
}
}
}
} else {
for(i in 1:n){
o.d <- order(ddx[i,]) # the distance vector if i_th object
for(j in low.num:n){
r <- ddx[i,o.d[j]]*rr
sc <- ddx[i,o.d[j]]
Kest.obs <- Kest.f.edge(ddx[o.d[1:j],o.d[1:j]],r,sc,d)
# check the values, if rejected, set the R[i] as the radius
lo.hi <- Kest.slopes$quan[[as.character(quan)]][j,]
flag <- (Kest.obs > lo.hi)
if(any(flag)){
if(j==low.num) R[i] <- 0
else R[i] <- ddx[i,o.d[j-1]]
break
} else if(j==n){
R[i] <- 0
break
}
if(R[i]==0){R[i]=sort(ddx[i,])[2]} # avoid 0 radius (necessary for outlyingness scores!)
}
}
}
return(list(R=R,KS=NULL))
}
# Aggregate the functions above into one
RKCCD_correct_quant <- function(datax,low.num=2,r.seq=10,
dom.method="greedy2", quan=0.99, simul=NULL, cls=NULL,ind=NULL, lenDlimit=Inf, niter=100, scores=F, min.cls=0){
if(low.num<2) stop("the lowest cardinality of a ball(low.num) can't be less than 2")
if(is.null(lenDlimit)) stop("the maximum index of the dominating point to be checked for silhouette(lenDlimit) can't be NA or NULL")
if(is.na(lenDlimit)) stop("the maximum index of the dominating point to be checked for silhouette(lenDlimit) can't be NA or NULL")
graph <- rccd.clustering_correct_quantile(datax, low.num, r.seq, method="non-dynamic", dom.method, quan, simul, niter,scores=scores)
ddatax <- as.matrix(dist(datax))
return(c(graph, rccd.silhouette(graph, ddatax, cls, min.cls=min.cls, ind, lenDlimit)))
}
# ccd clustering for arbitrary shapes of data
# mutual catch graph of RK-CCD
# edge correction included
# the balls are given with a K function estimation
# old name = ccd4.clustering_correct
# datax, the data set
# low.num, lowest number of a box cardinality
# r.seq, the number of radii used for each window, proximity region
# method, the method for dominating set algorithm
# simul, the simulation results if provided
rccd.clustering.mutual.connected_correct <- function(datax,low.num,r.seq, method="non-dynamic",
dom.method=NULL, quan, simul=NULL, niter,scores=F){
# info
nr <- nrow(datax)
nc <- ncol(datax)
ddatax <- as.matrix(dist(datax))
mac.eps <- .Machine$double.eps
# find all radii, and the dominating set
ccd.info <- ccd.Kest.edge.quantile(datax, ddatax, low.num, method, r.seq, quan, simul, niter, scores=scores)
r <- ccd.info$R
# M <- matrix(as.integer(ddatax < r + mac.eps), length(r))
M <- matrix(as.integer(ddatax <= r), length(r))
diag(M) <- 1
score <- rowSums(M)
# domination method is provided, find the dominating set
# if not, take all radii
if(!is.null(dom.method)){
if(dom.method=="greedy") D <- dominate.mat.greedy(M)
if(dom.method=="greedy2") D <- dominate.mat.greedy2(M)
if(dom.method=="ks") D <- dominate.mat.ks(M,ks)
} else {
D <- 1:nr
}
R <- r[D]
# find the edges of the mutual catch graph of RK-CCDs
M <- M[D,D]
M.dom <- diag(T,nrow(M))
for(i in 1:(nrow(M.dom)-1)){
for(j in (i+1):nrow(M.dom)){
temp <- (M[i,j] & M[j,i])
if(any(temp)) M.dom[i,j] <- M.dom[j,i] <- T
}
}
# find the disconnected components that are the clusters
D.member <- components.mat(M.dom)
member <- order(table(D.member),decreasing = T)
return(list(member = member, D.member=D.member, D=D, R=R, dist = ddatax))
}
# calculate the local distance-based outlier factor(LDOF) of a point x to a cluster
# x: a given point, cluster: a given cluster of points
# k is the number of nearest neighbors to consider, if not specified, k = min(dimension, data size)
# dist[[1]] is the dist vector from the point to the cluster, dist[[2]] is the dist matrix of the cluster
LDOF <- function(x, cluster, k = NULL, dist){
if(is.null(k)) {
k = min(ncol(cluster), nrow(cluster))
} else {
k = min(nrow(cluster), k)
}
ind = order(dist[[1]])[1:k]
ave1 =  mean(dist[[1]][ind])
if(k==1){ave2 = 1e-20} else {
inner.dist = dist[[2]][ind,ind]
ave2 = mean(inner.dist[which(upper.tri(inner.dist))])
}
result = ave1/ave2
return(result)
}
# the validation function for the clusters, does not need the actual cluster labels
# k is the number of nearest neighbors to consider, if not specified, k = min(dimension, data size)
# graph is the mutual catch graph of RK-CCD
# datax is the data set
# ddatax is the distance matrix
# cls: number of connected cluster to consider
rccd.clustering.nonvalid.knn <- function(Mgraph,datax,k = NULL,cls=NULL){
# ddatax = Mgraph$dist
datax = datax[Mgraph$D,]
ddatax = Mgraph$dist[Mgraph$D,Mgraph$D]
if(is.null(cls)){cls = length(Mgraph$member)}
n = nrow(datax)
d = ncol(datax)
cluster.ind = lapply(1:cls,function(x){
ind = which(Mgraph$D.member==Mgraph$member[x])
return(ind)
})
# which point is in which cluster
result = sapply(1:n, function(a){
if(!any(Mgraph$D.member[a]==Mgraph$member)){
dist.list = sapply(1:cls, function(b){
dist = list(ddatax[a,cluster.ind[[b]]],ddatax[cluster.ind[[b]],cluster.ind[[b]]])
x = datax[a,]
cluster = matrix(datax[cluster.ind[[b]],],ncol = d)
dist.cls = LDOF(x, cluster, k, dist)
return(dist.cls)
})
ind.cls = which(dist.list==min(dist.list))
return(Mgraph$member[ind.cls])
} else {return(Mgraph$D.member[a])}
})
return(result)
}
# for UN-MCCD
# the validation function for the clusters, does not need the actual cluster labels
# k is the number of nearest neighbors to consider, if not specified, k = min(dimension, data size)
# graph is the mutual catch graph of RK-CCD
# datax is the data set
# ddatax is the distance matrix
# cls: number of connected cluster to consider
rccd.clustering.nonvalid.knn1 <- function(graph,datax,k = NULL,cls=NULL){
ddatax = graph$dist.M
# datax = datax[graph$D,]
# ddatax = graph$dist[graph$D,graph$D]
if(is.null(cls)){cls = length(graph$D.member)}
n = nrow(datax)
d = ncol(datax)
cluster.ind = lapply(1:cls,function(x){
ind = which(graph$member==graph$D.member[x])
return(ind)
})
# which point is in which cluster
result = sapply(1:n, function(a){
if(!any(graph$member[a]==graph$D.member)){
dist.list = sapply(1:cls, function(b){
dist = list(ddatax[a,cluster.ind[[b]]],ddatax[cluster.ind[[b]],cluster.ind[[b]]])
x = datax[a,]
cluster = matrix(datax[cluster.ind[[b]],],ncol = d)
dist.cls = LDOF(x, cluster, k, dist)
return(dist.cls)
})
ind.cls = which(dist.list==min(dist.list))
return(graph$D.member[ind.cls])
} else {return(graph$member[a])}
})
return(result)
}
# incrementally add cluster points to find the clustering with maximum silhouette
# graph is the mutual catch graph of RK-CCD
# ddatax is the distance matrix
# cls is the actual classes
# ind is the set of indices of clusterings to be checked
# lenClimit is the maximum index of cluster to be checked for silhouette
# ind.C: optimal number of clusters
# label: clustering result
# max.sil: maximum silhouette index obtained
# min.cls: the minimum percentage accepted as a cluster
rccd.silhouette_mutual <- function(Mgraph,datax,ind=NULL, lenClimit=Inf, k=NULL, min.cls = 0){
n = nrow(datax)
cls.size = sort(table(Mgraph$D.member),decreasing = T)
# ddatax = Mgraph$dist
ddatax = Mgraph$dist[Mgraph$D,Mgraph$D]
lenC = min(length(Mgraph$member),lenClimit)
if(is.null(ind)){ind = n} else {ind = min(ind, n)}
lenC = length(which(cls.size>=round(min.cls*n)))
if(lenC<2){
sil.ind=1;label = rep(Mgraph$member[1],n);maxsil=NULL
} else {
result = lapply(2:lenC,function(t){
Mgraph.temp = Mgraph
Mgraph.temp$member = Mgraph$member[1:t]
label = rccd.clustering.nonvalid.knn(Mgraph.temp,datax,k,cls=NULL)
sil = mean(silhouette(label,ddatax)[1:ind,3])
return(list(label=label,sil=sil))
})
sil.ind = NULL
maxsil = -1e20
label = NULL
for(i in 1:length(result)){
if(result[[i]]$sil>maxsil){sil.ind = i+1;label = result[[i]]$label;maxsil = result[[i]]$sil}
}
}
return(list(sil=maxsil,sil.ind=sil.ind,label=label))
}
# For UN-MCCD
# incrementally add cluster points to find the clustering with maximum silhouette
# graph is the mutual catch graph of RK-CCD
# ddatax is the distance matrix
# cls is the actual classes
# ind is the set of indices of clusterings to be checked
# lenClimit is the maximum index of cluster to be checked for silhouette
# ind.C: optimal number of clusters
# label: clustering result
# max.sil: maximum silhouette index obtained
# min.cls: the minimum percentage accepted as a cluster
rccd.silhouette_mutual1 <- function(graph, datax,ind=NULL, lenClimit=Inf, k=NULL, min.cls = 0){
n = nrow(datax)
cls.size = sort(table(graph$member),decreasing = T)
ddatax = graph$dist.M
lenC = min(length(graph$D.member),lenClimit)
if(is.null(ind)){ind = n} else {ind = min(ind, n)}
lenC = length(which(cls.size>=round(min.cls*n)))
if(lenC<2){
sil.ind=1;label = rep(graph$D.member[1],n);maxsil=NULL
} else {
result = lapply(2:lenC,function(t){
graph.temp = graph
graph.temp$D.member = graph$D.member[1:t]
label = rccd.clustering.nonvalid.knn1(graph.temp,datax,k,cls=NULL)
sil = mean(silhouette(label,ddatax)[1:ind,3])
return(list(label=label,sil=sil))
})
sil.ind = NULL
maxsil = -1e20
label = NULL
for(i in 1:length(result)){
if(result[[i]]$sil>maxsil){sil.ind = i+1;label = result[[i]]$label;maxsil = result[[i]]$sil}
}
}
return(list(sil=maxsil,sil.ind=sil.ind,label=label))
}
##### breast_cancer data #####
load("/media/rui/exNVME/code_working_folder/general functions/RK-test_quantile/RK-test-simul_9d_999%.RData")
quant = 0.999
n_col = ncol(breast_cancer)
X = breast_cancer[, -n_col] # remove the class column for clustering
Y = breast_cancer[, n_col] # true cluster labels
# clustering with RK-CCD
RKCCD_label = RKCCD_clustering(datax=X, simul=simul, quant=quant)$label
RKCCD_clustering
RKCCD_clustering
source("/media/rui/exNVME/code_working_folder/CCDs_Clustering/UN-CCDs.R")
source("/media/rui/exNVME/code_working_folder/Algo_Compare_Clustering/Real_Datasets/Real_Data_Collection.R")
library(mclust)
library(parallel)
library(doParallel)
library(MASS)
library(cluster)
library(igraph)
cores = detectCores()
cl = makeCluster(cores)
registerDoParallel(cl)
##### hepatitis data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_19d_999%.RData")
method="descend"
n_col = ncol(hepatitis)
X = hepatitis[, -n_col] # remove the class column for clustering
Y = hepatitis[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_outlier(datax=x, simul=simul, method=method)$label
source("/media/rui/exNVME/code_working_folder/CCDs_Clustering/UN-CCDs.R")
source("/media/rui/exNVME/code_working_folder/Algo_Compare_Clustering/Real_Datasets/Real_Data_Collection.R")
library(mclust)
library(parallel)
library(doParallel)
library(MASS)
library(cluster)
library(igraph)
cores = detectCores()
cl = makeCluster(cores)
registerDoParallel(cl)
##### hepatitis data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_19d_999%.RData")
method="descend"
n_col = ncol(hepatitis)
X = hepatitis[, -n_col] # remove the class column for clustering
Y = hepatitis[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=x, simul=simul, method=method)$label
# number of clusters:
n_clusters = length(unique(UNCCD_label))
# ARI
ari = adjustedRandIndex(UNCCD_label, Y)
UNCCD_label
Y
##### hepatitis data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_19d_999%.RData")
method="descend"
n_col = ncol(hepatitis)
X = hepatitis[, -n_col] # remove the class column for clustering
Y = hepatitis[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
# number of clusters:
n_clusters = length(unique(UNCCD_label))
# ARI
ari = adjustedRandIndex(UNCCD_label, Y)
# the average silhouette index
sil = mean(silhouette(UNCCD_label, dist(X))[,3])
print(paste("iris x UN-CCDs: the ARI is", ari, "the average silhouette index is", sil, "number of clusters detected", n_clusters))
##### lymphography data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_18d_999%.RData")
method="descend"
n_col = ncol(lymphography)
X = lymphography[, -n_col] # remove the class column for clustering
Y = lymphography[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
# number of clusters:
n_clusters = length(unique(UNCCD_label))
# ARI
ari = adjustedRandIndex(UNCCD_label, Y)
# the average silhouette index
sil = mean(silhouette(UNCCD_label, dist(X))[,3])
print(paste("lymphography x UN-CCDs: the ARI is", ari, "the average silhouette index is", sil, "number of clusters detected", n_clusters))
##### iris data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_4d_90%.RData")
method="ascend"
n_col = ncol(iris)
X = iris[, -n_col] # remove the class column for clustering
Y = iris[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
##### iris data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_4d_90%.RData")
method="ascend"
n_col = ncol(iris)
X = iris[, -n_col] # remove the class column for clustering
Y = iris[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
##### seeds data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_7d_95%.RData")
method="ascend"
n_col = ncol(seeds)
X = seeds[, -n_col] # remove the class column for clustering
Y = seeds[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
# number of clusters:
n_clusters = length(unique(UNCCD_label))
# ARI
ari = adjustedRandIndex(UNCCD_label, Y)
# the average silhouette index
sil = mean(silhouette(UNCCD_label, dist(X))[,3])
print(paste("seeds x UN-CCDs: the ARI is", ari, "the average silhouette index is", sil, "number of clusters detected", n_clusters))
##### breast_cancer data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_9d_95%.RData")
method="ascend"
n_col = ncol(breast_cancer)
X = breast_cancer[, -n_col] # remove the class column for clustering
Y = breast_cancer[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
##### iris data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_4d_90%.RData")
method="ascend"
n_col = ncol(iris)
X = iris[, -n_col] # remove the class column for clustering
Y = iris[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
##### iris #####
iris = read.csv("iris.data", header=F)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
# remove duplicated rows
iris = as.matrix(distinct(as.data.frame(iris)))
# Check if there are NV values
anyNA(iris)
##### iris #####
iris = read.csv("iris.data", header=F)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
# remove duplicated rows
iris = as.matrix(distinct(as.data.frame(iris)))
# Check if there are NV values
anyNA(iris)
##### iris data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_4d_90%.RData")
method="ascend"
n_col = ncol(iris)
X = iris[, -n_col] # remove the class column for clustering
Y = iris[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
# number of clusters:
n_clusters = length(unique(UNCCD_label))
# ARI
ari = adjustedRandIndex(UNCCD_label, Y)
# the average silhouette index
sil = mean(silhouette(UNCCD_label, dist(X))[,3])
print(paste("iris x UN-CCDs: the ARI is", ari, "the average silhouette index is", sil, "number of clusters detected", n_clusters))
##### iris #####
iris = read.csv("iris.data", header=F)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
# remove duplicated rows
# iris = as.matrix(distinct(as.data.frame(iris)))
# Check if there are NV values
anyNA(iris)
##### iris #####
iris = read.csv("iris.data", header=F)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
# remove duplicated rows
# iris = as.matrix(distinct(as.data.frame(iris)))
# Check if there are NV values
anyNA(iris)
##### iris data #####
load("/media/rui/exNVME/code_working_folder/general functions/NN-test_quantile/NN-test-simul_4d_90%.RData")
method="ascend"
n_col = ncol(iris)
X = iris[, -n_col] # remove the class column for clustering
Y = iris[, n_col] # true cluster labels
# clustering with UN-CCD
UNCCD_label = UNCCD_clustering(datax=X, simul=simul, method=method)$label
##### iris #####
iris = read.csv("iris.data", header=F)
View(iris)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
iris = read.csv("iris.data", header=F)
X = iris[, -ncol(iris)]
# normalization
X = apply(X, 2, scale)
# remove the observations with NA values
X = X[!rowSums(is.na(X)) > 0, ]
Y = iris[,ncol(iris)]
Y = as.numeric(as.factor(Y))
iris = cbind(X, Y)
