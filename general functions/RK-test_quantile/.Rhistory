integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(sumM/((1:m)*(1:m)))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
test
dim(test$Kest.m)
(1:m)*(1:m)
m=100
(1:m)*(1:m)
dim(test$Kest.m)
SimuOnce()
niter
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(as.vector(sumM/((1:m)*(1:m))))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
test
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
as.vector(matrix(c(1:4),nrow=2))
Kest.simpois.edge.quantile
matrix(c(1:4),nrow=2)
as.vector(matrix(c(1:4),nrow=2))
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(as.vector(sumM/((1:m)*(1:m))))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
SimuOnce()
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(as.vector(sumM/((1:m)*(1:m))))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
Kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, Kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
Kest.simpois.edge.quantile
tt1 = Sys.time()
source("/media/rui/exNVME/code_working_folder/ccds/RK_CCD_New.R")
source("/media/rui/exNVME/code_working_folder/ccds/mKNN_CCD_functions.R")
source("/media/rui/exNVME/code_working_folder/general functions/count.R")
source("/media/rui/exNVME/code_working_folder/general functions/Uni-Gau_cls.R")
setwd("/media/rui/exNVME/code_working_folder/general functions/RK-test_quantile")
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
d = 2
rn = 10
quan = 0.99
niter = 1000
n = 720
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
test
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(as.vector(sumM/((1:m)*(1:m))))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
Kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(cbind, Kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(as.vector(sumM/((1:m)*(1:m))))
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
Kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
# Kest.m <- do.call(rbind, Kest.m)
#
# Kest.quan <- list()
# for(cur_quan in quan){
# temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
# Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
# }
# return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
return(list(Kest.m = Kest.m, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
test
matrix(c(1:4),nrow=2)
as.vector(test$Kest.m[[1]])
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
temp = as.vector(sumM/((1:m)*(1:m)))
return(temp)
},simplify=TRUE)
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
Kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, Kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$quan)
dim(test$Kest.m)
test$
test
test
# get the Kest envelopes provided by the simulations, new version 2
# edge correction, translation correction
# (the slopes of envelopes)
# added support for quantiles given in simulated envelopes
# old name = Kest.simpois2.quantile
# m is the number of observations in the original data set
# rn is the number of lengths in radii of Kest
# quan is the set of quantiles you wanna use
# niter is the number of iterations
# parallel computing
Kest.simpois.edge.quantile <- function(m,d,rn,quan,niter){
# do this for each simulated data set
# record points for simulated cases
r <- seq(1/rn,1,1/rn)
# simulation
Kest.m <- NULL
SimuOnce = function(){
rpoisball.unit <- function(n,d){
# inner ball and outer ball values
r1 <- runif(n,0,1)^(1/d)
norm.data <- matrix(mvrnorm(n,rep(0,d),diag(d)),ncol=d,byrow=T)
data1 <- apply(norm.data,1,function(x) x/sqrt(sum(x^2)))
data1 <- apply(data1,1,function(x) x*r1)
return(data1)
}
temp <- rpoisball.unit(m,d)
# distances
temp.dist <- as.matrix(dist(temp))
# calculate weights for correction
cons <- (sqrt(pi)*gamma((d+1)/2))/(2*gamma(d/2+1))
integrand <- function(t) sin(t)^d
ftemp <- sapply(temp.dist,function(t){
return(integrate(integrand,0,acos(t/2))$value)
},simplify = TRUE)
ftemp <- matrix(ftemp,nrow=nrow(temp.dist),byrow = FALSE)
ftemp <- cons*(1/ftemp)
# analyze
diag(temp.dist) <- Inf
result <- sapply(r,function(x){
Mtemp <- (temp.dist < x)
Mtemp[lower.tri(Mtemp)] <- 0
ftemp[lower.tri(ftemp)] <- 0
Mtemp <- Mtemp*ftemp
sumM <- cumsum(2*colSums(Mtemp))
return(sumM/((1:m)*(1:m)))
},simplify=TRUE)
return(as.vector(result))
}
cores = detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
Kest.m = foreach(1:niter,.packages = c("MASS","cluster","igraph")) %dopar% SimuOnce()
stopCluster(cl)
Kest.m <- do.call(rbind, Kest.m)
Kest.quan <- list()
for(cur_quan in quan){
temp <- apply(Kest.m,2, quantile, probs = as.numeric(cur_quan))
Kest.quan[[as.character(cur_quan)]] <- matrix(temp,nrow=m)
}
return(list(Kest.m = Kest.m, quan=Kest.quan, r=r))
}
test = Kest.simpois.edge.quantile(m=90, d, rn, quan, niter=100)
dim(test$Kest.m)
test
dim(test$Kest.m)
test = Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
dim(test$Kest.m)
test
test = Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
dim(test$Kest.m)
test
test = Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
dim(test$Kest.m)
test
load("RK-test_2d_99%.RData")
simu.list[[100]]
simul.list[[100]]$quan
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
simul.list[[100]]$quan
set.seed(1234)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=100, d, rn, quan, niter=100)
Kest.simpois.edge.quantile(m=200, d, rn, quan, niter=1000)
dim(test$Kest.m)
Kest.simpois.edge.quantile(m=200, d, rn, quan, niter=1000)
dim(test$Kest.m)
Kest.simpois.edge.quantile(m=200, d, rn, quan, niter=1000)
tt1 = Sys.time()
source("/media/rui/exNVME/code_working_folder/ccds/RK_CCD_New.R")
source("/media/rui/exNVME/code_working_folder/ccds/mKNN_CCD_functions.R")
source("/media/rui/exNVME/code_working_folder/general functions/count.R")
source("/media/rui/exNVME/code_working_folder/general functions/Uni-Gau_cls.R")
setwd("/media/rui/exNVME/code_working_folder/general functions/RK-test_quantile")
library(parallel)
library(doParallel)
library(MASS)
library(igraph)
d = 2
rn = 10
quan = 0.99
niter = 10000
n = 800
# set.seed(1234)
# cores = detectCores()
# cl <- makeCluster(cores)
# registerDoParallel(cl)
# simul.list = foreach(x=c(1:n),.packages = c("MASS","cluster","igraph")) %dopar%
#   Kest.simpois.edge.quantile(x, d, rn, quan, niter)
# stopCluster(cl)
#
# tt2 = Sys.time()
# tt2-tt1
simul = Kest.simpois.edge.quantile(n, d, rn, quan, niter)
stopCluster(cl)
gc()
